{"guid":"999bc890-4efd-4892-ae77-cfe082e16172","title":"RDBMS Specific recommendations","path":"help\\production\\using\\rdbms-specific-recommendations.md","fullText":"---\nproduct: campaign\ntitle: RDBMS Specific recommendations\ndescription: RDBMS Specific recommendations\nfeature: Monitoring\nbadge-v7-prem: label=\"On-premise/hybrid only\" type=\"Caution\" url=\"https://experienceleague.adobe.com/docs/campaign-classic/using/installing-campaign-classic/architecture-and-hosting-models/hosting-models-lp/hosting-models.html\" tooltip=\"Applies to on-premise and hybrid deployments only\"\naudience: production\ncontent-type: reference\ntopic-tags: database-maintenance\nexl-id: a586d70b-1b7f-47c2-a821-635098a70e45\n---\n# RDBMS Specific recommendations{#rdbms-specific-recommendations}\n\n\n\nTo help you set up maintenance plans, this section lists some recommendations and best practices adapted to the various RDBMS engines that Adobe Campaign supports. However, these are only recommendations. It is up to you to adapt them to your needs, in keeping with your internal procedure and constraints. Your database administrator has the responsibility to build and execute these plans.\n\n## PostgreSQL {#postgresql}\n\n### Detecting large tables {#detecting-large-tables}\n\n1. You can add the following view to your database:\n\n   ```\n   create or replace view uvSpace\n    as\n    SELECT c1.relname AS tablename, c2.relname AS indexname, c2.relpages * 8  / 1024 AS size_mbytes, c2.relfilenode AS filename, cast(0 AS bigint) AS row_count\n    FROM pg_class c1, pg_class c2, pg_index i\n    WHERE c1.oid = i.indrelid AND i.indexrelid = c2.oid\n    UNION\n    SELECT pg_class.relname AS tablename, NULL::\"unknown\" AS indexname, pg_class.relpages * 8  /1024  AS size_mbytes, pg_class.relfilenode AS filename, cast(pg_class.reltuples as bigint) AS row_count\n    FROM pg_class\n    WHERE pg_class.relkind = 'r'::\"char\"\n    ORDER BY 3 DESC, 1, 2 DESC;\n   ```\n\n1. You can run this query to spot large tables and indexes:\n\n   ```\n   SELECT * FROM uvSpace;\n   ```\n\n   Alternatively, you can run this query, for example, to see all index sizes collectively:\n\n   ```\n   SELECT\n      tablename,\n      sum(size_mbytes) AS \"sizeMB_all\",\n      (\n         SELECT sum(size_mbytes)\n         FROM uvspace\n         AS uv2\n         WHERE\n            INDEXNAME IS NULL\n            AND uv1.tablename = uv2.tablename\n      ) AS \"sizeMB_data\",\n      (\n         SELECT sum(size_mbytes)\n         FROM uvspace \n         AS uv2 \n         WHERE\n            INDEXNAME IS NOT NULL\n            AND uv1.tablename = uv2.tablename\n      ) AS \"sizeMB_index\",\n      (\n         SELECT ROW_COUNT\n         FROM uvspace\n         AS uv2\n         WHERE\n            INDEXNAME IS NULL\n            AND uv1.tablename = uv2.tablename\n      ) AS ROWS FROM uvspace AS uv1\n      GROUP BY tablename\n      ORDER BY 2 DESC\n   ```\n\n### Simple maintenance {#simple-maintenance}\n\n   >[!IMPORTANT]\n   >\n   >Adobe strongly suggests not to run VACUUM FULL on Campaign Adobe-hosted database setups.The maintenance suggested are a guide for ON-PREMISE installations only. For custom table implementations and schemas, use VACUUM FULL at your own risk as VACUUM - without monitoring - can exclusively lock tables causing stalled queries - and in some cases, lock up the entire database.\n\nIn PostgreSQL, you can use these typical keywords:\n\n* VACUUM (FULL, ANALYZE, VERBOSE)\n\nTo run the VACUUM operation, and analyze and time it, you can use this syntax:\n\n```\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) <table>;\n```\n\nWe strongly recommend that you do not omit the ANALYZE statement. Otherwise, the vacuumed table is left with no statistics. The reason is that a new table is built, then the old one is deleted. As a result, the object ID (OID) of the table changes, but no statistics are computed. Consequently, you will immediately experience performance issues.\n\nHere is a typical example of an SQL maintenance plan to be executed on a regular basis:\n\n```\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdelivery;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdeliverystat;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflow;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowevent;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowjob;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowlog;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowtask;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkjoblog;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkjob;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsaddress;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdeliverypart;\n\n\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsmirrorpageinfo;\n```\n\n>[!NOTE]\n>\n>* Adobe recommends starting with smaller tables: this way, if the process fails on large tables (where the risk of failure is highest), at least part of the maintenance has been completed.\n>* Adobe recommends that you add the tables that are specific to your data model, which can be subject to significant updates. This can be the case for **NmsRecipient** if you have large daily data replication flows.\n>* The VACUUM statement will lock the table, which pauses some processes while maintenance is carried out.\n>* For very large tables (typically above 5 Gb), the VACUUM FULL statement can become quite inefficient and take a very long time. Adobe does not recommend using it for the **YyyNmsBroadLogXxx** table.\n>* This maintenance operation can be implemented by an Adobe Campaign workflow, using an **[!UICONTROL SQL]** activity. For more on this, refer to [this section](../../workflow/using/architecture.md). Make sure you schedule maintenance for a low activity time that does not collide with your backup window.\n>\n\n### Rebuilding a database {#rebuilding-a-database}\n\nPostgreSQL does not provide an easy way to perform an online table rebuild since the VACUUM FULL statement locks the table, thus preventing regular production. This means that maintenance has to be performed when the table is not used. You can either:\n\n* perform maintenance when the Adobe Campaign platform is stopped,\n* stop the various Adobe Campaign subservices that are likely to write in the table being rebuilt (**nlserver stop wfserver instance_name** to stop the workflow process).\n\nHere is an example of table defragmentation using specific functions to generate the necessary DDL. The following SQL lets you create two new functions: **GenRebuildTablePart1** and **GenRebuildTablePart2**, which can be used to generate the necessary DDL to recreate a table.\n\n* The first function lets you create a work table (** _tmp** here) which is a copy of the original table.\n* The second function then deletes the original table and renames the work table and its indexes.\n* Using two functions instead of one means that if the first one fails, you don't run the risk of deleting the original table.\n\n```\n -- --------------------------------------------------------------------------\n -- Generate the CREATE TABLE DDL for a table\n -- --------------------------------------------------------------------------\n create or replace function GenTableDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecFld RECORD;\n vstrDDL text;\n vstrFields text;\n vstrNsTable text;\n vstrTableSpace text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n SELECT\n pg_catalog.quote_ident(n.nspname) || '.' || pg_catalog.quote_ident(c.relname),\n pg_catalog.quote_ident(t.spcname)\n INTO\n vstrNsTable, vstrTableSpace\n FROM\n pg_namespace n, pg_class c left outer join pg_tablespace t on c.reltablespace = t.oid\n WHERE\n n.oid = c.relnamespace AND\n c.relname = vstrTable;\n \n vstrDDL = 'CREATE TABLE ' || vstrNsTable || '_tmp(';\n \n vstrFields = ;\n FOR vrecFld IN\n SELECT\n pg_catalog.quote_ident(a.attname) ||\n ' ' || t.typname ||\n case when t.typname='varchar' then '(' || cast(a.atttypmod-4 as text) || ')'\n when t.typname='numeric' then '(' || cast((a.atttypmod-4)/65536 as text) || ',' || cast((a.atttypmod-4)%65536 as text) || ')'\n else end ||\n case when a.attnotnull then ' not null' else end ||\n case when a.atthasdef then ' default '|| d.adsrc else end as DDL\n FROM\n pg_type t, pg_class c, pg_attribute a LEFT OUTER JOIN pg_attrdef d ON d.adrelid=a.attrelid and d.adnum=a.attnum\n WHERE \n a.attnum > 0 AND\n a.attrelid = c.oid AND\n t.oid = a.atttypid AND\n c.relname = vstrTable\n ORDER BY\n a.attnum\n LOOP\n IF vstrFields <> THEN\n vstrFields = vstrFields || ',' || chr(10) || ' ';\n ELSE\n vstrFields = vstrFields || chr(10) || ' ';\n END IF;\n vstrFields = vstrFields || vrecFld.DDL;\n END LOOP;\n \n vstrDDL = vstrDDL || vstrFields || chr(10) || ')';\n if vstrTableSpace <> then\n vstrDDL = vstrDDL || ' TABLESPACE ' || vstrTableSpace;\n end if;\n vstrDDL = vstrDDL || ';' || chr(10);\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;\n\n -- --------------------------------------------------------------------------\n -- Generate the CREATE INDEX DDL for a table\n -- --------------------------------------------------------------------------\n create or replace function GenIndexDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecIndex RECORD;\n vstrDDL text;\n viFld integer;\n vstrFld text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n FOR vrecIndex IN\n SELECT\n i.indkey, i.indisunique,\n pg_catalog.quote_ident(c.relname) as tablename,\n pg_catalog.quote_ident(ic.relname) as indexname,\n pg_catalog.quote_ident(t.spcname) as tablespace\n FROM\n pg_class c, pg_index i, pg_class ic left outer join pg_tablespace t on ic.reltablespace = t.oid\n WHERE\n i.indexrelid = ic.oid AND\n i.indrelid = c.oid AND\n c.relname = vstrTable\n LOOP\n \n  vstrDDL = vstrDDL || 'CREATE ';\n  if vrecIndex.indisunique then\n  vstrDDL = vstrDDL || 'UNIQUE ';\n  end if;\n  vstrDDL = vstrDDL ||\n   'INDEX ' ||vrecIndex.indexname || '_tmp ON ' ||\n   vrecIndex.tablename || '_tmp(';\n \n  FOR viFld IN array_lower(vrecIndex.indkey, 1) .. array_upper(vrecIndex.indkey, 1) LOOP\n  SELECT pg_catalog.quote_ident(a.attname) INTO vstrFld \n  FROM \n   pg_attribute a, pg_class c\n  WHERE \n   a.attnum = vrecIndex.indkey[viFld] AND\n   a.attrelid = c.oid AND c.relname=vstrTable;\n  \n  vstrDDL = vstrDDL || vstrFld;\n  if viFld <> array_upper(vrecIndex.indkey, 1) then\n   vstrDDL = vstrDDL || ', ';\n  end if;\n  END LOOP;\n  vstrDDL = vstrDDL || ')';\n \n  if vrecIndex.tablespace <> then\n  vstrDDL = vstrDDL || 'TABLESPACE ' || vrecIndex.tablespace;\n  end if;\n  vstrDDL = vstrDDL || ';' || chr(10);\n \n END LOOP;\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;\n\n -- --------------------------------------------------------------------------\n -- Generate the ALTER INDEX RENAME for a table\n -- --------------------------------------------------------------------------\n create or replace function GenRenameIndexDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecIndex RECORD;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n FOR vrecIndex IN\n  SELECT\n  pg_catalog.quote_ident(n.nspname) as namespace,\n  pg_catalog.quote_ident(ic.relname) as indexname\n  FROM\n  pg_namespace n, pg_class c, pg_index i, pg_class ic\n  WHERE\n  i.indexrelid = ic.oid AND\n  n.oid = ic.relnamespace AND\n  i.indrelid = c.oid AND\n  c.relname = vstrTable\n LOOP\n \n  vstrDDL = vstrDDL || 'ALTER INDEX ' || vrecIndex.namespace || '.' || vrecIndex.indexname ||\n    '_tmp RENAME TO ' || vrecIndex.indexname ||\n    ';' || chr(10);\n END LOOP;\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;\n\n -- --------------------------------------------------------------------------\n -- Build a copy of a table, with index\n -- --------------------------------------------------------------------------\n create or replace function GenRebuildTablePart1(text) returns text as $$\n declare\n vstrTable text;\n vstrTmp text;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n  \n vstrDDL = ;\n \n SELECT GenTableDDL(vstrTable) INTO vstrTmp;\n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n \n vstrDDL = vstrDDL|| 'INSERT INTO ' || vstrTable || '_tmp SELECT * FROM ' || vstrTable || ';'||chr(10);\n SELECT GenIndexDDL(vstrTable) INTO vstrTmp;\n \n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n vstrDDL = vstrDDL|| 'VACUUM ANALYSE '|| vstrTable || '_tmp;' ||chr(10);\n \n return vstrDDL;\n end;\n $$ LANGUAGE plpgsql;\n \n -- --------------------------------------------------------------------------\n -- Drop the original table and rename the copy\n -- --------------------------------------------------------------------------\n create or replace function GenRebuildTablePart2(text) returns text as $$\n declare\n vstrTable text;\n vstrTmp text;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n  \n vstrDDL = 'DROP TABLE ' || vstrTable||';'|| chr(10);\n vstrDDL = vstrDDL|| 'ALTER TABLE ' || vstrTable || '_tmp RENAME TO ' || vstrTable ||';'|| chr(10);\n \n SELECT GenRenameIndexDDL(vstrTable) INTO vstrTmp;\n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n \n return vstrDDL;\n end;\n $$ LANGUAGE plpgsql;\n\n```\n\nThe following example can be used in a workflow to rebuild the required tables rather than using the **vacuum/rebuild** command:\n\n```\nfunction sqlGetMemo(strSql)\n {\n var res = sqlSelect(\"s, m:memo\", strSql);\n return res.s.m.toString();\n }\n\n function RebuildTable(strTable)\n {\n // Rebuild a table_tmp\n var strSql = sqlGetMemo(\"select GenRebuildTablePart1('\"+strTable+\"')\");\n logInfo(\"Rebuilding table '\"+strTable+\"'...\");\n // logInfo(strSql);\n sqlExec(strSql);\n \n // If fails, there is an exception thrown and so we do not delete the original table\n strSql = sqlGetMemo(\"select GenRebuildTablePart2('\"+strTable+\"')\");\n logInfo(\"Swapping table '\"+strTable+\"'...\");\n //logInfo(strSql);\n sqlExec(strSql);\n }\n \n RebuildTable('nmsrecipient');\n RebuildTable('nmsrcpgrlrel');\n // ... other tables here\n\n```\n\n## Oracle {#oracle}\n\nPlease contact your database administrator to find out about the procedures best suited to your version of Oracle.\n\n## Microsoft SQL Server {#microsoft-sql-server}\n\n>[!NOTE]\n>\n>For Microsoft SQL Server, you can use the maintenance plan detailed on [this page](https://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html).\n\nThe example below concerns Microsoft SQL Server 2005. If you are using another version, contact your database administrator to find out about maintenance procedures.\n\n1. First, connect to Microsoft SQL Server Management Studio, with a login with administrator rights.\n1. Go to the **[!UICONTROL Management > Maintenance Plans]** folder, right-click on it and choose **[!UICONTROL Maintenance Plan Wizard]**.\n1. Click **[!UICONTROL Next]** when the first page comes up.\n1. Select the type of maintenance plan you want to create (separate schedules for each task or single schedule for the whole plan), then click the **[!UICONTROL Change...]** button.\n1. In the **[!UICONTROL Job schedule properties]** window, select the desired execution settings and click **[!UICONTROL OK]**, then click **[!UICONTROL Next]**.\n1. Select the maintenance tasks you want to perform, then click **[!UICONTROL Next]**.\n\n   >[!NOTE]\n   >\n   >We recommend performing at least the maintenance tasks shown below. You may also select the statistics update task, although it is already carried out by the database cleanup workflow.\n\n1. In the drop-down list, select the database on which you want to run the **[!UICONTROL Database Check Integrity]** task.\n1. Select the database and click **[!UICONTROL OK]**, then click **[!UICONTROL Next]**.\n1. Configure the maximum size allocated to your database, then click **[!UICONTROL Next]**.\n\n   >[!NOTE]\n   >\n   >If the size of the database exceeds this threshold, the maintenance plan will try to delete unused data to free up space.\n\n1. Reorganize or rebuild the index:\n\n    * If the index fragmentation rate is between 10% and 40%, a reorganization is recommended.\n\n      Choose which databases and objects (tables or views) you want to reorganize, then click **[!UICONTROL Next]**.\n\n      >[!NOTE]\n      >\n      >Depending on your configuration you can choose either the previously selected tables, or all tables in your database.\n\n    * If the index fragmentation rate is higher than 40%, a rebuild is recommended.\n\n      Select the options you want to apply to the index rebuild task, then click **[!UICONTROL Next]**.\n\n      >[!NOTE]\n      >\n      >The rebuild index process is more constricting in terms of processor use and it locks the database resources. Select the **[!UICONTROL Keep index online while reindexing]** option if you want the index to be available during the rebuild.\n\n1. Select the options you want to display in the activity report, then click **[!UICONTROL Next]**.\n1. Check the list of tasks configured for the maintenance plan, then click **[!UICONTROL Finish]**.\n\n   A summary of the maintenance plan and the statuses of its various steps is displayed.\n\n1. Once the maintenance plan is complete, click **[!UICONTROL Close]**.\n1. In the Microsoft SQL Server explorer, double-click the **[!UICONTROL Management > Maintenance Plans]** folder.\n1. Select the Adobe Campaign maintenance plan: the various steps are detailed in a workflow.\n\n   Note that an object has been created in the **[!UICONTROL SQL Server Agent > Jobs]** folder. This object lets you start the maintenance plan. In our example, there is only one object since all the maintenance tasks are part of the same plan.\n\n   >[!IMPORTANT]\n   >\n   >For this object to run, the Microsoft SQL Server agent must be enabled.\n\n**Configuring a separate database for working tables**\n\n>[!NOTE]\n>\n>This configuration is optional.\n\nThe **WdbcOptions_TempDbName** option allows you to configure a separate database for working tables on Microsoft SQL Server. This optimizes backups and replication.\n\nThis option can be used if you want the working tables (for example, the tables created during the execution of a workflow) to be created on another database.\n\nWhen you set the option to \"tempdb.dbo.\", the working tables are created on the default temporary database of Microsoft SQL Server. The database administrator needs to allow write access to the tempdb database.\n\nIf the option is set, it is used on all Microsoft SQL Server databases that are configured in Adobe Campaign (main database and external accounts). Note that if two external accounts share the same server, conflicts may happen (as the tempdb is unique). In the same way, if two Campaign instances use the same MSSQL server, there may be conflicts if they use the same tempdb.\n","headers":[["title","RDBMS Specific recommendations"],["description","RDBMS Specific recommendations"],["feature","Monitoring"],["topic-tags","database-maintenance"]],"sections":[{"section":"RDBMS Specific recommendations","sectionId":"34c77b57-951a-4d4c-be97-cf41be98efe7","paragraphs":["To help you set up maintenance plans, this section lists some recommendations and best practices adapted to the various RDBMS engines that Adobe Campaign supports. However, these are only recommendations. It is up to you to adapt them to your needs, in keeping with your internal procedure and constraints. Your database administrator has the responsibility to build and execute these plans."]},{"section":"PostgreSQL","sectionId":"6686a674-f2a0-4408-b884-9ab6e1c51727","paragraphs":[]},{"section":"Detecting large tables","sectionId":"803ec7e0-9ae3-43b3-b95c-3bfd470c3f79","paragraphs":["You can add the following view to your database:","create or replace view uvSpace\n as\n SELECT c1.relname AS tablename, c2.relname AS indexname, c2.relpages * 8  / 1024 AS size_mbytes, c2.relfilenode AS filename, cast(0 AS bigint) AS row_count\n FROM pg_class c1, pg_class c2, pg_index i\n WHERE c1.oid = i.indrelid AND i.indexrelid = c2.oid\n UNION\n SELECT pg_class.relname AS tablename, NULL::\"unknown\" AS indexname, pg_class.relpages * 8  /1024  AS size_mbytes, pg_class.relfilenode AS filename, cast(pg_class.reltuples as bigint) AS row_count\n FROM pg_class\n WHERE pg_class.relkind = 'r'::\"char\"\n ORDER BY 3 DESC, 1, 2 DESC;","You can run this query to spot large tables and indexes:","SELECT * FROM uvSpace;","Alternatively, you can run this query, for example, to see all index sizes collectively:","SELECT\n   tablename,\n   sum(size_mbytes) AS \"sizeMB_all\",\n   (\n      SELECT sum(size_mbytes)\n      FROM uvspace\n      AS uv2\n      WHERE\n         INDEXNAME IS NULL\n         AND uv1.tablename = uv2.tablename\n   ) AS \"sizeMB_data\",\n   (\n      SELECT sum(size_mbytes)\n      FROM uvspace \n      AS uv2 \n      WHERE\n         INDEXNAME IS NOT NULL\n         AND uv1.tablename = uv2.tablename\n   ) AS \"sizeMB_index\",\n   (\n      SELECT ROW_COUNT\n      FROM uvspace\n      AS uv2\n      WHERE\n         INDEXNAME IS NULL\n         AND uv1.tablename = uv2.tablename\n   ) AS ROWS FROM uvspace AS uv1\n   GROUP BY tablename\n   ORDER BY 2 DESC"]},{"section":"Simple maintenance","sectionId":"b88c1b9c-d613-42c2-b91b-bf5ff7661d05","paragraphs":["IMPORTANT","Adobe strongly suggests not to run VACUUM FULL on Campaign Adobe-hosted database setups.The maintenance suggested are a guide for ON-PREMISE installations only. For custom table implementations and schemas, use VACUUM FULL at your own risk as VACUUM - without monitoring - can exclusively lock tables causing stalled queries - and in some cases, lock up the entire database.","In PostgreSQL, you can use these typical keywords:","VACUUM (FULL, ANALYZE, VERBOSE)","To run the VACUUM operation, and analyze and time it, you can use this syntax:","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) <table>;","We strongly recommend that you do not omit the ANALYZE statement. Otherwise, the vacuumed table is left with no statistics. The reason is that a new table is built, then the old one is deleted. As a result, the object ID (OID) of the table changes, but no statistics are computed. Consequently, you will immediately experience performance issues.","Here is a typical example of an SQL maintenance plan to be executed on a regular basis:","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdelivery;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdeliverystat;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflow;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowevent;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowjob;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowlog;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkworkflowtask;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkjoblog;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) xtkjob;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsaddress;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsdeliverypart;","\\timing on\nVACUUM (FULL, ANALYZE, VERBOSE) nmsmirrorpageinfo;","NOTE","Adobe recommends starting with smaller tables: this way, if the process fails on large tables (where the risk of failure is highest), at least part of the maintenance has been completed.\nAdobe recommends that you add the tables that are specific to your data model, which can be subject to significant updates. This can be the case for NmsRecipient if you have large daily data replication flows.\nThe VACUUM statement will lock the table, which pauses some processes while maintenance is carried out.\nFor very large tables (typically above 5 Gb), the VACUUM FULL statement can become quite inefficient and take a very long time. Adobe does not recommend using it for the YyyNmsBroadLogXxx table.\nThis maintenance operation can be implemented by an Adobe Campaign workflow, using an SQL activity. For more on this, refer to this section. Make sure you schedule maintenance for a low activity time that does not collide with your backup window."]},{"section":"Rebuilding a database","sectionId":"d9188c7e-8b20-40c1-b773-a1446e2128c1","paragraphs":["PostgreSQL does not provide an easy way to perform an online table rebuild since the VACUUM FULL statement locks the table, thus preventing regular production. This means that maintenance has to be performed when the table is not used. You can either:","perform maintenance when the Adobe Campaign platform is stopped,\nstop the various Adobe Campaign subservices that are likely to write in the table being rebuilt (nlserver stop wfserver instance_name to stop the workflow process).","Here is an example of table defragmentation using specific functions to generate the necessary DDL. The following SQL lets you create two new functions: GenRebuildTablePart1 and GenRebuildTablePart2, which can be used to generate the necessary DDL to recreate a table.","The first function lets you create a work table (** _tmp** here) which is a copy of the original table.\nThe second function then deletes the original table and renames the work table and its indexes.\nUsing two functions instead of one means that if the first one fails, you don't run the risk of deleting the original table.","-- --------------------------------------------------------------------------\n -- Generate the CREATE TABLE DDL for a table\n -- --------------------------------------------------------------------------\n create or replace function GenTableDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecFld RECORD;\n vstrDDL text;\n vstrFields text;\n vstrNsTable text;\n vstrTableSpace text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n SELECT\n pg_catalog.quote_ident(n.nspname) || '.' || pg_catalog.quote_ident(c.relname),\n pg_catalog.quote_ident(t.spcname)\n INTO\n vstrNsTable, vstrTableSpace\n FROM\n pg_namespace n, pg_class c left outer join pg_tablespace t on c.reltablespace = t.oid\n WHERE\n n.oid = c.relnamespace AND\n c.relname = vstrTable;\n \n vstrDDL = 'CREATE TABLE ' || vstrNsTable || '_tmp(';\n \n vstrFields = ;\n FOR vrecFld IN\n SELECT\n pg_catalog.quote_ident(a.attname) ||\n ' ' || t.typname ||\n case when t.typname='varchar' then '(' || cast(a.atttypmod-4 as text) || ')'\n when t.typname='numeric' then '(' || cast((a.atttypmod-4)/65536 as text) || ',' || cast((a.atttypmod-4)%65536 as text) || ')'\n else end ||\n case when a.attnotnull then ' not null' else end ||\n case when a.atthasdef then ' default '|| d.adsrc else end as DDL\n FROM\n pg_type t, pg_class c, pg_attribute a LEFT OUTER JOIN pg_attrdef d ON d.adrelid=a.attrelid and d.adnum=a.attnum\n WHERE \n a.attnum > 0 AND\n a.attrelid = c.oid AND\n t.oid = a.atttypid AND\n c.relname = vstrTable\n ORDER BY\n a.attnum\n LOOP\n IF vstrFields <> THEN\n vstrFields = vstrFields || ',' || chr(10) || ' ';\n ELSE\n vstrFields = vstrFields || chr(10) || ' ';\n END IF;\n vstrFields = vstrFields || vrecFld.DDL;\n END LOOP;\n \n vstrDDL = vstrDDL || vstrFields || chr(10) || ')';\n if vstrTableSpace <> then\n vstrDDL = vstrDDL || ' TABLESPACE ' || vstrTableSpace;\n end if;\n vstrDDL = vstrDDL || ';' || chr(10);\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;","-- --------------------------------------------------------------------------\n -- Generate the CREATE INDEX DDL for a table\n -- --------------------------------------------------------------------------\n create or replace function GenIndexDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecIndex RECORD;\n vstrDDL text;\n viFld integer;\n vstrFld text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n FOR vrecIndex IN\n SELECT\n i.indkey, i.indisunique,\n pg_catalog.quote_ident(c.relname) as tablename,\n pg_catalog.quote_ident(ic.relname) as indexname,\n pg_catalog.quote_ident(t.spcname) as tablespace\n FROM\n pg_class c, pg_index i, pg_class ic left outer join pg_tablespace t on ic.reltablespace = t.oid\n WHERE\n i.indexrelid = ic.oid AND\n i.indrelid = c.oid AND\n c.relname = vstrTable\n LOOP\n \n  vstrDDL = vstrDDL || 'CREATE ';\n  if vrecIndex.indisunique then\n  vstrDDL = vstrDDL || 'UNIQUE ';\n  end if;\n  vstrDDL = vstrDDL ||\n   'INDEX ' ||vrecIndex.indexname || '_tmp ON ' ||\n   vrecIndex.tablename || '_tmp(';\n \n  FOR viFld IN array_lower(vrecIndex.indkey, 1) .. array_upper(vrecIndex.indkey, 1) LOOP\n  SELECT pg_catalog.quote_ident(a.attname) INTO vstrFld \n  FROM \n   pg_attribute a, pg_class c\n  WHERE \n   a.attnum = vrecIndex.indkey[viFld] AND\n   a.attrelid = c.oid AND c.relname=vstrTable;\n  \n  vstrDDL = vstrDDL || vstrFld;\n  if viFld <> array_upper(vrecIndex.indkey, 1) then\n   vstrDDL = vstrDDL || ', ';\n  end if;\n  END LOOP;\n  vstrDDL = vstrDDL || ')';\n \n  if vrecIndex.tablespace <> then\n  vstrDDL = vstrDDL || 'TABLESPACE ' || vrecIndex.tablespace;\n  end if;\n  vstrDDL = vstrDDL || ';' || chr(10);\n \n END LOOP;\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;","-- --------------------------------------------------------------------------\n -- Generate the ALTER INDEX RENAME for a table\n -- --------------------------------------------------------------------------\n create or replace function GenRenameIndexDDL(text) returns text as $$\n declare\n vstrTable text;\n vrecIndex RECORD;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n \n vstrDDL = ;\n \n FOR vrecIndex IN\n  SELECT\n  pg_catalog.quote_ident(n.nspname) as namespace,\n  pg_catalog.quote_ident(ic.relname) as indexname\n  FROM\n  pg_namespace n, pg_class c, pg_index i, pg_class ic\n  WHERE\n  i.indexrelid = ic.oid AND\n  n.oid = ic.relnamespace AND\n  i.indrelid = c.oid AND\n  c.relname = vstrTable\n LOOP\n \n  vstrDDL = vstrDDL || 'ALTER INDEX ' || vrecIndex.namespace || '.' || vrecIndex.indexname ||\n    '_tmp RENAME TO ' || vrecIndex.indexname ||\n    ';' || chr(10);\n END LOOP;\n \n return vstrDDL;\n END;\n $$ LANGUAGE plpgsql;","-- --------------------------------------------------------------------------\n -- Build a copy of a table, with index\n -- --------------------------------------------------------------------------\n create or replace function GenRebuildTablePart1(text) returns text as $$\n declare\n vstrTable text;\n vstrTmp text;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n  \n vstrDDL = ;\n \n SELECT GenTableDDL(vstrTable) INTO vstrTmp;\n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n \n vstrDDL = vstrDDL|| 'INSERT INTO ' || vstrTable || '_tmp SELECT * FROM ' || vstrTable || ';'||chr(10);\n SELECT GenIndexDDL(vstrTable) INTO vstrTmp;\n \n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n vstrDDL = vstrDDL|| 'VACUUM ANALYSE '|| vstrTable || '_tmp;' ||chr(10);\n \n return vstrDDL;\n end;\n $$ LANGUAGE plpgsql;\n \n -- --------------------------------------------------------------------------\n -- Drop the original table and rename the copy\n -- --------------------------------------------------------------------------\n create or replace function GenRebuildTablePart2(text) returns text as $$\n declare\n vstrTable text;\n vstrTmp text;\n vstrDDL text;\n begin\n vstrTable = lower($1);\n  \n vstrDDL = 'DROP TABLE ' || vstrTable||';'|| chr(10);\n vstrDDL = vstrDDL|| 'ALTER TABLE ' || vstrTable || '_tmp RENAME TO ' || vstrTable ||';'|| chr(10);\n \n SELECT GenRenameIndexDDL(vstrTable) INTO vstrTmp;\n vstrDDL = vstrDDL|| vstrTmp || chr(10);\n \n return vstrDDL;\n end;\n $$ LANGUAGE plpgsql;","The following example can be used in a workflow to rebuild the required tables rather than using the vacuum/rebuild command:","function sqlGetMemo(strSql)\n {\n var res = sqlSelect(\"s, m:memo\", strSql);\n return res.s.m.toString();\n }","function RebuildTable(strTable)\n {\n // Rebuild a table_tmp\n var strSql = sqlGetMemo(\"select GenRebuildTablePart1('\"+strTable+\"')\");\n logInfo(\"Rebuilding table '\"+strTable+\"'...\");\n // logInfo(strSql);\n sqlExec(strSql);\n \n // If fails, there is an exception thrown and so we do not delete the original table\n strSql = sqlGetMemo(\"select GenRebuildTablePart2('\"+strTable+\"')\");\n logInfo(\"Swapping table '\"+strTable+\"'...\");\n //logInfo(strSql);\n sqlExec(strSql);\n }\n \n RebuildTable('nmsrecipient');\n RebuildTable('nmsrcpgrlrel');\n // ... other tables here"]},{"section":"Oracle","sectionId":"87162d02-c146-482b-ac07-ed9aa05b50c7","paragraphs":["Please contact your database administrator to find out about the procedures best suited to your version of Oracle."]},{"section":"Microsoft SQL Server","sectionId":"7876a105-31bf-4172-808e-cadfaf9f9933","paragraphs":["NOTE","For Microsoft SQL Server, you can use the maintenance plan detailed on this page.","The example below concerns Microsoft SQL Server 2005. If you are using another version, contact your database administrator to find out about maintenance procedures.","First, connect to Microsoft SQL Server Management Studio, with a login with administrator rights.","Go to the Management > Maintenance Plans folder, right-click on it and choose Maintenance Plan Wizard.","Click Next when the first page comes up.","Select the type of maintenance plan you want to create (separate schedules for each task or single schedule for the whole plan), then click the Change... button.","In the Job schedule properties window, select the desired execution settings and click OK, then click Next.","Select the maintenance tasks you want to perform, then click Next.","NOTE","We recommend performing at least the maintenance tasks shown below. You may also select the statistics update task, although it is already carried out by the database cleanup workflow.","In the drop-down list, select the database on which you want to run the Database Check Integrity task.","Select the database and click OK, then click Next.","Configure the maximum size allocated to your database, then click Next.","NOTE","If the size of the database exceeds this threshold, the maintenance plan will try to delete unused data to free up space.","Reorganize or rebuild the index:","If the index fragmentation rate is between 10% and 40%, a reorganization is recommended.","Choose which databases and objects (tables or views) you want to reorganize, then click Next.","NOTE","Depending on your configuration you can choose either the previously selected tables, or all tables in your database.","If the index fragmentation rate is higher than 40%, a rebuild is recommended.","Select the options you want to apply to the index rebuild task, then click Next.","NOTE","The rebuild index process is more constricting in terms of processor use and it locks the database resources. Select the Keep index online while reindexing option if you want the index to be available during the rebuild.","Select the options you want to display in the activity report, then click Next.","Check the list of tasks configured for the maintenance plan, then click Finish.","A summary of the maintenance plan and the statuses of its various steps is displayed.","Once the maintenance plan is complete, click Close.","In the Microsoft SQL Server explorer, double-click the Management > Maintenance Plans folder.","Select the Adobe Campaign maintenance plan: the various steps are detailed in a workflow.","Note that an object has been created in the SQL Server Agent > Jobs folder. This object lets you start the maintenance plan. In our example, there is only one object since all the maintenance tasks are part of the same plan.","IMPORTANT","For this object to run, the Microsoft SQL Server agent must be enabled.","Configuring a separate database for working tables","NOTE","This configuration is optional.","The WdbcOptions_TempDbName option allows you to configure a separate database for working tables on Microsoft SQL Server. This optimizes backups and replication.","This option can be used if you want the working tables (for example, the tables created during the execution of a workflow) to be created on another database.","When you set the option to \"tempdb.dbo.\", the working tables are created on the default temporary database of Microsoft SQL Server. The database administrator needs to allow write access to the tempdb database.","If the option is set, it is used on all Microsoft SQL Server databases that are configured in Adobe Campaign (main database and external accounts). Note that if two external accounts share the same server, conflicts may happen (as the tempdb is unique). In the same way, if two Campaign instances use the same MSSQL server, there may be conflicts if they use the same tempdb."]}]}